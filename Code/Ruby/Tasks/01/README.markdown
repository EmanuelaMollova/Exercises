# Първо домашно

[Monkey patching](http://en.wikipedia.org/wiki/Monkey_patch) се нарича промяната
на вградени класове (като например `String`), често с цел добавяне на полезна
функционалност. В едни (редки) случаи това е страхотна идея и резултира в много по-добър
код. В други е ужасна идея и не трябва да се прави. Във всички случаи е супер забавно.

Искаме отрано да изкараме от системата ви нуждата за monkey patching.
Затова тази задача иска от вас да направите цели осем monkey patch-а.

## `Integer#prime?`

Добавете метод в `Integer`, който проверява дали число е [просто](https://en.wikipedia.org/wiki/Prime_number).

Пример:

```
-13.prime? # false
4.prime?   # false
5.prime?   # true
17.prime?  # true
144.prime? # false
```

## `Integer#prime_factors`

Добавете метод в `Integer`, който разлага число на прости множители и ги връща в
списък.

Пример:

```
9.prime_factors   # [3, 3]
35.prime_factors  # [5, 7]
12.prime_factors  # [2, 2, 3]
36.prime_factors  # [2, 2, 3, 3]
```

Детайли:

* Множителите трябва да са подредени във възходящ ред.
* Смятайте, че в 0 и 1 методът е недефиниран. Ние няма да го викаме с такива аргументи в тестовете.
* Методът трябва да работи с отрицателни числа, като: `n.prime_factors == -n.prime_factors`.

## `Integer#harmonic`

Сумата от реципрочните на първите n естествени числа се нарича n-то [хармонично число](http://en.wikipedia.org/wiki/Harmonic_number).

Добавете метод в `Integer`, който конвертира число до съответното му хармонично.
Върнатият резултат трябва да бъде от тип `Rational`.

Пример:

```
1.harmonic  # 1/1
2.harmonic  # 3/2
10.harmonic # 7381/2520
42.harmonic # 12309312989335019/2844937529085600
```

Детайли:

* Приемете, че за `n <= 0`, методът е недефиниран.

## `Integer#digits`

Добавете метод в `Integer`, който да връща списък от цифрите на числото.

Пример:

```
9.digits      # [9]
82.digits     # [8, 2]
123345.digits # [1, 2, 3, 3, 4, 5]
```

Детайли:

* Забележете, че редът се запазва.
* Методът трябва да работи с отрицателни числа, като: `n.digits == -n.digits`.

## `Array#frequencies`

Добавете метод в `Array`, който да връща хеш, като на различните елементи на
списъка съпоставя броят им на срещане.

Пример:

```
[:a, :a, :a].frequencies          # { :a => 3 }
[:a, :a, 42, "ZOMG!"].frequencies # { :a => 2, 42 => 1, "ZOMG!" => 1 }
```

Детайли:

* Не променяйте списъка.

## `Array#average`

Добавете метод в `Array`, който да пресмята средното аритметично на елементите в
списъка.

Пример:

```
[4, 8, 15, 16, 23, 42].average          # 18.0
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].average # 5.5
```

Детайли:

* Приемете, че за празен списък, метода е недефиниран.
* Не променяйте списъка.

## `Array#drop_every(n)`

Добавете метод в `Array`, който да връща нов списък, пропускайки всеки n-ти елемент.

Пример:

```
[4, 8, 15, 16, 23, 42].drop_every(2) # [4, 15, 23]
[4, 8, 15, 16, 23, 42].drop_every(3) # [4, 8, 16, 23]
```

## `Array#combine_with(other)`

Добавете метод в `Array`, който комбинира елементите на списъка, върху когото е
извикан с елементите на подадения като аргумент списък. Връща се нов списък.
Важат следните правила при комбинирането:

1. Добавя се първият елемент от списъка, върху когото се вика метода.
2. Добавя се първият елемент от списъка, подаден като аргумент.
3. Продължава се с вторите елементи, с третите и така докато се изчерпят елементите.
4. Ако елементите на единия от списъците се изчерпят преди елементите на другия
списък, то останалите елементите се добавят в края на резултата.
5. Ако някой от списъците е празен по начало, връщат се елементите на другия.

Пример:

```
[:a, :b, :c].combine_with([])              # [:a, :b, :c]
[:a, :b, :c].combine_with([1, 2, 3])       # [:a, 1, :b, 2, :c, 3]
[1, 2, 3, 4, 5].combine_with([:a, :b, :c]) # [1, :a, 2, :b, 3, :c, 4, 5]
```

## Бележки

Материалът, който сме ви показали на лекции може да не е напълно достатъчен да решите тази задача. При всички случаи, той е недостатъчен за да решите задачата качествено. За да се справите добре, ще се наложи да се поразтърсите. [Google](http://google.com/) е ваш приятел. Също така, [APIDock](http://apidock.com/) може да ви бъде много полезен.

Като за първа задача, почти няма да вземаме много точки за лош стил. Изключения правят неконсистентна индентация, много глупави имена на променливи (това включва шльокавица) или пълно объркване на прости неща (като локални и глобални променливи). Когато крайния срок на задачата изтече, ще оставим подробни коментари за грешки в стила. Хвърлете един поглед на style guide-а преди да пишете код.

**Не използвайте никакви модули**. `require` е забранена думичка.

## Примерен тест

Примерния тест за задачата може да намерите в [хранилището с домашните ето тук](https://github.com/fmi/ruby-homework/blob/master/01/sample_spec.rb). Как да си го пуснете може да [видите в ръководството](/tasks/guide).
